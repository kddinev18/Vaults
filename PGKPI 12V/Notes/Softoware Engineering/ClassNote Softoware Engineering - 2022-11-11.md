---
tags: [classnote, SE, template]
creation date: 2022-11-11 18:15
modification date: 2022-11-11 18:15
---
Author: Калоян Динев
Links: [[Software Engineering - Main]]
```button
name Go Back
type link
action obsidian://open?vault=PGKPI%2012V&file=Index
```
# ClassNote - Softoware Engineering
2022-11-11

1.  Въведение в базите от данни. 
2.  Типове данни. 
3.  Основни команди.
4.   Основни SQL команди за работа с бази данни – създаване, промяна и премахване на бази от данни, таблици и колони. 
5.  Моделиране на релационни бази от данни – нормализация и нормални форми. 
6.  Типове връзки, каскадни операции и ограничения. 
7.  Заявки за извличане и промяна на данни (SELECT, INSERT, UPDATE, DELETE). 
8.  Сложни заявки за извличане на данни. 
9.  Съединения на таблици (SQL JOIN). 
10.   Агрегиращи функции и групиране на данни. 
11.  Филтриране и сортиране на групирани данни. Функции, транзакции и съхранени процедури.
# Notes
## 1. Въведение в базите от данни. 
**а) База от данни**

Базата данни е организирана колекция от структурирана информация или данни, обикновено съхранявани електронно в компютърна система. Базата данни обикновено се управлява от система за управление на база данни (СУБД).

Данните обикновено се моделират в редове и колони в поредица от таблици, за да направят обработката и заявките за данни ефективни. След това данните могат да бъдат лесно достъпни, управлявани, модифицирани, актуализирани, контролирани и организирани. Повечето бази данни използват структуриран език за заявки (SQL) за писане и заявяване на данни.

**б) SQL**

SQL е език за програмиране, използван от почти всички релационни бази данни за заявки, манипулиране и дефиниране на данни.

**в) Типове база данни**

- Релационна

Елементите в релационна база данни са организирани като набор от таблици с колони и редове. Технологията за релационни бази данни осигурява най-ефективния и гъвкав начин за достъп до структурирана информация.


- Нерелационна

NoSQL или нерелационна база данни позволява неструктурирани и полуструктурирани данни да бъдат съхранявани и манипулирани (за разлика от релационна база данни, която определя как трябва да бъдат съставени всички данни, вмъкнати в базата данни).

## 2. Типове данни
SQL Data Type е атрибут, който указва типа данни на всеки обект. Всяка колона, променлива и израз имат свързан тип данни в SQL. Можете да използвате тези типове данни, докато създавате вашите таблици. Можете да изберете тип данни за колона на таблица въз основа на вашите изисквания.

Глваните типове данни в една релационна база данни са:
**а) Низови типове данни**
- char - Максимална дължина от 8000 знака. (знаци с фиксирана дължина, различни от Unicode)
- varchar - Максимум 8000 знака. (Данни с променлива дължина, различни от Unicode).
- nchar - Максимална дължина от 4000 знака. (Уникод с фиксирана дължина)
- nvarchar - Максимална дължина от 4000 знака. (Уникод с променлива дължина)
- binary - Максимална дължина от 8000 байта (двоични данни с фиксирана дължина)
- varbinary - Максимална дължина от 8000 байта (двоични данни с променлива дължина)
- image - Максимална дължина от 2 147 483 647 байта. (Двоични данни с променлива дължина)

**б) Номерични типове данни**

- bit
- tinyint
- smallint
- int
- bigint
- decimal(p,s)
- money
- float
- real

**в) Времеви типове данни**

- datetime
- datetime2
- date
- time
- datetimeoffset
- timestamp
## 3. Основни команди.
Езикът за дефиниране на данни или DDL командите на структорираният език за заявки (SQL) се използват за описание/дефиниране на схемата на базата данни. Тези команди се занимават със създаването на схема на база данни и нейните допълнителни модификации. Някои популярни DDL команди са CREATE, ALTER, DROP, TRUNCATE

Командите на езика за манипулиране на данни (DML) в SQL се занимават с манипулиране на записи на данни, съхранявани в таблиците на базата данни. Той не се занимава с промени в обектите на базата данни и нейната структура. Общоизвестните DML команди са INSERT, UPDATE, DELETE, SELECT.

##  4. Основни SQL команди за работа с бази данни
### 4.1. DDL

| Command  | Description                                                                                   |
| -------- | --------------------------------------------------------------------------------------------- |
| CREATE   | Използва се за създаване на обекти на база данни като база данни и таблица на база данни.     |
| ALTER    | Използва се за модифициране и преименуване на елементи от съществуваща таблица на база данни. |
| DROP     | Използва се за премахване на цяла база данни или таблица на база данни.                       |
| TRUNCATE | Използва се за премахване на всички записи от таблица на база данни.                          |

#### 1. CREATE

CREATE е команда за език за дефиниране на данни (DDL), която се използва за създаване на обекти на база данни, като база данни и таблица на база данни.

Синтаксисът за създаване на база данни е както следва:

```sql
CREATE DATABASE database_name;
```

Основният синтаксис за създаване на таблица в SQL е както следва:

```sql
CREATE TABLE public.customers  
(  
column_name_1  datatype [NULL | NOT NULL],  
column_name_2  datatype [NULL | NOT NULL],  
.  
.  
.  
column_name_n  datatype [NULL | NOT NULL] )
```

#### 2. ALTER

Командата ALTER в SQL се използва за добавяне, преименуване или модифициране, премахване/изтриване на колони в съществуваща таблица на база данни. Освен това може да се използва за добавяне и премахване на различни ограничения върху съществуваща таблица на база данни.

Синтаксисът, използван за промяна на таблица в SQL чрез добавяне на нова колона, е както следва:
```sql
ALTER TABLE table_name   ADD (Columnname_1  datatype)
```

Синтаксисът, използван за преименуване на таблица, е както следва:

```cs
ALTER TABLE table_name_1   RENAME TO table_new_name;
```


Синтаксисът, използван за промяна на таблица в SQL чрез изтриване на съществуващи колони, е както следва:

```cs
ALTER TABLE table_name   DROP columnname_1 , columnname_2, ...
```

#### 3. TRUNCATE

Командата TRUNCATE TABLE се използва за премахване на всички записи на данни от таблицата на базата данни. Той изтрива всички редове за постоянно. Следователно, не можем да извършим операция за връщане назад, за да отменим команда TRUNCATE.

Общият синтаксис, използван за писане на команда TRUNCATE, е както следва:
```sql
TRUNCATE TABLE table_name;
```


#### 4. DROP

Командата DROP TABLE в SQL се използва за изтриване на обект на база данни от базата данни. Можем дори да изтрием базата данни с помощта на командата DROP. Не можем да извършим операция за връщане назад, за да отменим команда DROP база данни/таблица.

Основният синтаксис за писане на команда DROP за изтриване на база данни в SQL е както следва:

```sql
DROP DATABASE database_name;
```



Синтаксисът за писане на команда DROP за изтриване на база данни в SQL е както следва:

```sql
DROP TABLE table_name;
```

### 4.2. DML

| Command | Description                                                                           |
| ------- | ------------------------------------------------------------------------------------- |
| SELECT  | Използва се за извличане на избрани полета или колони от таблица на база данни        |
| INSERT  | Използва се за вмъкване на нови записи с данни или редове в таблицата на базата данни |
| UPDATE  | Използва се за задаване на нова стойност на поле или колона за определен запис        |
| DELETE  | Използва се за премахване на един или повече редове от таблицата на базата данни      |

#### 1. SELECT

Командата или изразът SELECT в SQL се използва за извличане на записи с данни от таблицата на базата данни и представянето им под формата на набор от резултати. Обикновено се счита за DQL команда, но може да се разглежда и като DML.

Синтаксисът за писане на оператор UPDATE е както следва:

```sql
SELECT column_name1, column_name2, …  
FROM table_name  
WHERE condition_ expression;
```

Параметрите, използвани в горния синтаксис, са както следва:

-   **column_name1, column_name2, … :** Посочете имената на колони, които трябва да бъдат извлечени или избрани за крайния набор от резултати.
-   **table_name:** Посочете името на таблицата на базата данни, от която тези резултати трябва да бъдат извлечени.
-   **condition_expression:** Задайте израза на условието за филтриране на записи за крайния набор от резултати.

#### 2. INSERT

Командите INSERT в SQL се използват за вмъкване на записи с данни или редове в таблица на база данни. В оператор INSERT ние указваме както имената на колони, за които трябва да се направи запис, така и стойността на данните, която трябва да бъде вмъкната.

Основният синтаксис за писане на оператори INSERT в SQL е както следва:

```sql
INSERT INTO table_name (column_name_1, column_name_2, column_name_3, ...)  
VALUES (value1, value2, value3, ...)
```

Под VALUES, имаме предвид стойността на съответните колони.

#### 3. UPDATE

Командата UPDATE се използва за промяна на стойността на съществуваща колона в таблица на база данни.

Синтаксисът за писане на оператор UPDATE е както следва:

```sql
UPDATE table_name  
SET column_name_1 = value1, column_name_2 = value2, ...  
WHERE condition;
```

#### 4. DELETE

Командата DELETE в SQL се използва за премахване на един или повече редове от таблицата на базата данни. Той не изтрива записите с данни за постоянно. Винаги можем да извършим операция за връщане назад, за да отменим команда DELETE. С операторите DELETE можем да използваме клаузата WHERE за филтриране на конкретни редове.

Синтаксисът за писане на оператор DELETE е както следва:

```sql
DELETE FROM table_name WHERE condition;
```

## 5. Моделиране на релационни бази от данни
Нормализирането на базата данни е процес на организиране на данни в таблици по такъв начин, че резултатите от използването на базата от данни да са винаги недвусмислени и по предназначение. Такава нормализация е присъща на теорията за релационните бази данни. Това може да има ефект на дублиране на данни в базата данни и често води до създаване на допълнителни таблици.

Степените на нормализиране на таблиците на релационни бази данни са дефинирани и включват:

**Първа нормална форма (1NF).** 
Това е "основното" ниво на нормализиране на базата данни и обикновено съответства на дефиницията на всяка база данни, а именно:

Съдържа двумерни таблици с редове и колони. Всяка колона съответства на подобект или атрибут на обекта, представен от цялата таблица.Всеки ред представлява уникален екземпляр на този подобект или атрибут и трябва да се различава по някакъв начин от всеки друг ред (т.е. не са възможни дублиращи се редове). 
Всички записи във всяка колона трябва да са от един и същи вид. Например в колоната с етикет „Клиент“ са разрешени само имена или номера на клиенти.

**Втора нормална форма (2NF).** 
При това ниво на нормализиране всяка колона в таблица, която не е определяща за съдържанието на друга колона, сама трябва да бъде функция на другите колони в таблицата. Например в таблица с три колони, съдържаща идентификационния номер на клиента, продадения продукт и цената на продукта при продажба, цената ще бъде функция на идентификационния номер на клиента (с право на отстъпка) и конкретния продукт. В този случай се казва, че данните в третата колона зависят от данните в първата и втората колона. Тази зависимост не се среща в случая 1NF.

Колоната, означена като идентификатор на клиента, се счита за първичен ключ, тъй като това е колона, която уникално идентифицира редовете в тази таблица и отговаря на другите приети изисквания в стандартната схема за управление на база данни: тя няма NULL стойности и нейните стойности няма да се променят с течение на времето.

В примера по-горе другите заглавки на колони се считат за кандидат ключове. Атрибутите на тези кандидат ключове, които ги правят уникални, се наричат основни атрибути.

**Трета нормална форма (3NF).** 
Във втората нормална форма все още са възможни модификации, тъй като промяна в един ред в таблица може да засегне данните, които препращат към тази информация от друга таблица. Например, използвайки току-що цитираната таблица с клиенти, премахването на ред, описващ клиентска покупка (може би поради връщане), също ще премахне факта, че продуктът има определена цена. В третата нормална форма тези таблици ще бъдат разделени на две таблици, така че ценообразуването на продукта да се проследява отделно.


## 6. Типове връзки, каскадни операции и ограничения.
Всяко свързване между два типа обекти се нарича връзка. Субектите участват във връзката. Представен е с форма на диамант.

Имаме два типа обекти „Клиент“ (Customer_id, Име, Град, Телефон) и „Акаунт“ (Account_no, Тип, Баланс). Съхраняваме данните на „Клиент“ в една таблица и данните за неговите сметки в таблицата „Акаунт“. Сега, за да свържем тези две таблици, трябва да вмъкнем първичния ключ „Customer_id“ на таблицата „Customer“ в таблицата „Account“. Този ключ действа като външен ключ за таблицата „Акаунт“ и препраща към колона със същото име в таблицата „Клиент“. Така се установява връзка между две таблици. Има три вида връзки, които могат да съществуват между два обекта.

- Връзка едно към едно
- Връзка "един към много" или "много към едно".
- Връзка много към много

### One-to-One Relationship

Такава връзка съществува, когато всеки запис от една таблица е свързан само с един запис от другата таблица.

**_Например,_** Ако има два обекта „Лице“ (Id, Име, Възраст, Адрес) и „Паспорт“ (Passport_id, Passport_no). Така че всеки човек може да има само един паспорт и всеки паспорт принадлежи само на един човек.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-one-to-one-relationship-example-e89f4cf71cbaee76.jpg)

Подобна връзка не е много често срещана. Такава връзка обаче се използва за целите на сигурността. В горния пример можем лесно да съхраним идентификатора на паспорта само в таблицата „Лице“. Но ние правим друга таблица за „Паспорт“, тъй като номерът на паспорта може да е чувствителна информация и трябва да бъде скрит от определени потребители. Така че, като направим отделна таблица, ние осигуряваме допълнителна сигурност, която само определени потребители на базата данни могат да я видят.

### One-to-Many or Many-to-One Relationship

Такава връзка съществува, когато всеки запис от една таблица може да бъде свързан с един или повече от един запис от другата таблица. Тази връзка е най-често срещаната връзка. Връзката "един към много" може също да се каже като връзка "много към едно", в зависимост от начина, по който я разглеждаме.

**_Например,_** Ако има два типа обекти „Клиент“ и „Акаунт“, тогава всеки „Клиент“ може да има повече от един „Акаунт“, но всеки „Акаунт“ се държи само от един „Клиент“. В този пример можем да кажем, че всеки клиент е свързан с много акаунти. Така че това е връзка "един към много". Но ако го видим по друг начин, т.е. много акаунти са свързани с един клиент, тогава можем да кажем, че това е връзка много към едно.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-one-to-many-relationship-example-0d5c065e28b4f23a.jpg)

### Many-to-Many Relationship

Такава връзка съществува, когато всеки запис от първата таблица може да бъде свързан с един или повече от един запис от втората таблица и единичен запис от втората таблица може да бъде свързан с един или повече от един запис от първата таблица. Връзка много към много може да се разглежда като две релации едно към много, които са свързани чрез „свързваща таблица“ или „асоциирана таблица“. Свързващата таблица свързва две таблици, като има полета, които са първичен ключ на другите две таблици. Можем да разберем това със следния пример.

**Пример:** Ако има два типа обекти „Клиент“ и „Продукт“, тогава всеки клиент може да купи повече от един продукт и един продукт може да бъде закупен от много различни клиенти.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-many-to-many-relationship-example-bd4be3b525b7bdcd.jpg)

Сега, за да разберем концепцията на свързващата таблица тук, можем да имаме обекта „Поръчка“ като свързваща таблица, която свързва обекта „Клиент“ и „Продукт“. Можем да прекъснем тази връзка много към много в две връзки едно към много. Първо, всеки „Клиент“ може да има много „Поръчки“, докато всяка „Поръчка“ е свързана само с един „Клиент“. Второ, всяка „Поръчка“ е свързана само с един продукт, където може да има много поръчки за един и същ продукт.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-many-to-many-relationship-examples-c961b29d4c8aa6a5.jpg)

В горната концепция за свързване може да се разбере с помощта на вземане под внимание на всички атрибути на обектите „Клиент“, „Поръчка“ и „Продукт“. Можем да видим, че първичният ключ на обекта „Клиент“ и „Продукт“ са включени в таблицата за свързване, т.е. таблицата „Поръчка“. Тези ключове действат като външни ключове, докато препращат към съответната таблица от таблицата "Поръчка".

---
### Каскадни операции

CASCADE в SQL се използва за едновременно изтриване или актуализиране на запис от дъщерната и родителската таблица. Ключовата дума CASCADE се използва като връзка при писане на заявката за ON DELETE или ON UPDATE. Ако ключовата дума cascade се добави към заявка, написана за родителската таблица, тогава и родителската, и дъщерната таблица се променят съответно при изпълнението на заявката.

Да предположим, че сме създали две таблици с ВЪНШЕН КЛЮЧ във връзка с външен ключ, което прави и двете таблици родител и дете. След това дефинираме клауза ON DELETE CASCADE за един FOREIGN KEY, който трябва да бъде зададен, за да може другият да успее в каскадните операции. Ако ON DELETE CASCADE е дефинирана само за една клауза FOREIGN KEY, тогава каскадните операции ще изведат грешка.

```sql
FOREIGN KEY (emp_id) REFERENCES Employee (emp_id) ON DELETE CASCADE
```

Клаузата ON UPDATE CASCADE се използва за **актуализиране** на съвпадащите записи от дъщерната таблица автоматично, когато актуализираме редовете в родителската таблица. Следващият пример го обяснява по-ясно.

```sql
ALTER TABLE Payment ADD CONSTRAINT `payment_fk`   
FOREIGN KEY(emp_id) REFERENCES Employee (emp_id) ON UPDATE CASCADE;
```

---
### Ограничения

В таблица на база данни можем да добавим правила към колона, известна като **ограничения**. Тези правила контролират данните, които могат да се съхраняват в колона.

Например, ако колона има ограничение `NOT NULL` , това означава, че колоната не може да съхранява стойности `NULL`.

Ограниченията, използвани в SQL са:

| Constraint   | Description                         |
|--------------|-------------------------------------|
| NOT NULL     | values cannot be null               |
| UNIQUE       | values cannot match any older value |
| PRIMARY KEY  | used to uniquely identify a row     |
| FOREIGN KEY  | references a row in another table   |
| CHECK        | validates condition for new value   |
| DEFAULT      | set default value if not passed     |
| CREATE INDEX | used to speedup the read process    |


**Забележка:** Тези ограничения се наричат още ограничения за интегритет.

---
#### NOT NULL Constraint

Ограничението `NOT NULL` в колона означава, че колоната не може да съхранява `NULL` стойности. Например,

```
CREATE TABLE Colleges (
  college_id INT NOT NULL,
  college_code VARCHAR(20) NOT NULL,
  college_name VARCHAR(50)
);
```

---

#### UNIQUE Constraint

Ограничението `UNIQUE` в колона означава, че колоната трябва да има уникална стойност. Например,

```
CREATE TABLE Colleges (
  college_id INT NOT NULL UNIQUE,
  college_code VARCHAR(20) UNIQUE,
  college_name VARCHAR(50)
);
```


---

#### PRIMARY KEY Constraint

Ограничението `PRIMARY KEY` е просто комбинация от `NOT NULL` и `UNIQUE` ограничения. Това означава, че стойността на колоната се използва за уникално идентифициране на реда. Например,

```
CREATE TABLE Colleges (
  college_id INT PRIMARY KEY,
  college_code VARCHAR(20) NOT NULL,
  college_name VARCHAR(50)
);
```


---

#### FOREIGN KEY Constraint

Ограничението `FOREIGN KEY` (`REFERENCES` в някои бази данни) в колона се използва за препратка към запис, който съществува в друга таблица. Например,

```
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  customer_id int REFERENCES Customers(id)
);
```


---

#### CHECK Constraint

Ограничението `CHECK` проверява условието, преди да разреши стойности в таблица. Например,

```
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  amount int CHECK (amount >= 100)
);
```


---

#### DEFAULT Constraint

Ограничението `DEFAULT` се използва за задаване на стойността по подразбиране, ако се опитаме да съхраним `NULL` в колона. Например,

```
CREATE TABLE College (
  college_id INT PRIMARY KEY,
  college_code VARCHAR(20),
  college_country VARCHAR(20) DEFAULT 'US'
);
```
## 7. Заявки за извличане и промяна на данни
### SELECT
Операторът SQL **SELECT** се използва за извличане на данните от таблица на база данни, която връща тези данни под формата на таблица с резултати. Тези таблици с резултати се наричат набори от резултати.

Основният синтаксис на израза SELECT е както следва −

```sql
SELECT column1, column2, columnN FROM table_name;
```

Тук колона1, колона2... са полетата на таблица, чиито стойности искате да извлечете. Ако искате да извлечете всички полета, налични в полето, тогава можете да използвате следния синтаксис.

```sql
SELECT * FROM table_name;
```

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

```sql
SELECT ID, NAME, SALARY FROM CUSTOMERS;
```

| ID  | NAME     | SALARY   |
| --- | -------- | -------- |
| 1   | Ramesh   | 2000.00  |
| 2   | Khilan   | 1500.00  |
| 3   | kaushik  | 2000.00  |
| 4   | Chaitali | 6500.00  |
| 5   | Hardik   | 8500.00  |
| 6   | Komal    | 4500.00  |
| 7   | Muffy    | 10000.00 |


### INSERT
SQL **INSERT INTO** изявлението се използва за добавяне на нови редове от данни към таблица в базата данни.

Има два основни синтаксиса на израза INSERT INTO, които са показани по-долу.

```sql
INSERT INTO TABLE_NAME (колона1, колона2, колона3,...колонаN)
СТОЙНОСТИ (стойност1, стойност2, стойност3,...стойностN);
```

Тук колона1, колона2, колона3,...колонаN са имената на колоните в таблицата, в които искате да вмъкнете данните.

Може да не е необходимо да указвате името на колоната(ите) в SQL заявката, ако добавяте стойности за всички колони на таблицата. Но се уверете, че редът на стойностите е в същия ред като колоните в таблицата.

Синтаксисът **SQL INSERT INTO** ще бъде както следва −

INSERT INTO TABLE_NAME VALUES (стойност1,стойност2,стойност3,...стойностN);

```sql
INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (2, 'Khilan', 25, 'Delhi', 1500.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (3, 'kaushik', 23, 'Kota', 2000.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (5, 'Hardik', 27, 'Bhopal', 8500.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (6, 'Komal', 22, 'MP', 4500.00 );
```

| ID  | NAME     | AGE | ADDRESS   | SALARY  |
| --- | -------- | --- | --------- | ------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00 |
| 2   | Khilan   | 25  | Delhi     | 1500.00 |
| 3   | kaushik  | 23  | Kota      | 2000.00 |
| 4   | Chaitali | 25  | Mumbai    | 6500.00 |
| 5   | Hardik   | 27  | Bhopal    | 8500.00 |
| 6   | Komal    | 22  | MP        | 4500.00 |
### UPDATE
SQL **UPDATE** заявката се използва за модифициране на съществуващите записи в таблица. Можете да използвате клаузата WHERE със заявката UPDATE, за да актуализирате избраните редове, в противен случай ще бъдат засегнати всички редове.

Можете да комбинирате N на брой условия, като използвате операторите И или ИЛИ.

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

```sql
UPDATE CUSTOMERS
SET ADDRESS = 'Pune'
WHERE ID = 6;
```

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | Pune      | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |
### DELETE
SQL DELETE Query се използва за изтриване на съществуващите записи от таблица.

Можете да използвате клаузата WHERE със заявка DELETE, за да изтриете избраните редове, в противен случай всички записи ще бъдат изтрити.

Основният синтаксис на заявката DELETE с клаузата WHERE е както следва −

Можете да комбинирате N на брой условия, като използвате оператори И или ИЛИ.

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

```sql
DELETE FROM CUSTOMERS
WHERE ID = 6;
```

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |
## 8. Сложни заявки за извличане на данни.
Подзаявка или вътрешна заявка или вложена заявка е заявка в рамките на друга SQL заявка и е вградена в клаузата WHERE. Подзаявка се използва за връщане на данни, които ще бъдат използвани в основната заявка като условие за допълнително ограничаване на данните, които трябва да бъдат извлечени. Подзаявките могат да се използват с операторите SELECT, INSERT, UPDATE и DELETE заедно с операторите като =, <, >, >=, <=, IN, BETWEEN и т.н.

- Подзаявките трябва да бъдат оградени в скоби.
- Една подзаявка може да има само една колона в клаузата SELECT, освен ако в основната заявка има няколко колони за подзаявката, за да сравни избраните колони.
- Команда ORDER BY не може да се използва в подзаявка, въпреки че основната заявка може да използва ORDER BY. Командата GROUP BY може да се използва за изпълнение на същата функция като ORDER BY в подзаявка.
- Подзаявки, които връщат повече от един ред, могат да се използват само с оператори с множество стойности, като оператор IN.
- Списъкът SELECT не може да включва препратки към стойности, които се оценяват на BLOB, ARRAY, CLOB или NCLOB.
- Подзаявка не може да бъде незабавно затворена в зададена функция.
- Операторът BETWEEN не може да се използва с подзаявка. Операторът BETWEEN обаче може да се използва в подзаявката.
### SELECT

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 35  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

```sql
SELECT * 
FROM CUSTOMERS 
WHERE ID IN (SELECT ID 
	FROM CUSTOMERS 
    WHERE SALARY > 4500) ;
```


| ID  | NAME     | AGE | ADDRESS | SALARY   |
| --- | -------- | --- | ------- | -------- |
| 4   | Chaitali | 25  | Mumbai  | 6500.00  |
| 5   | Hardik   | 27  | Bhopal  | 8500.00  |
| 7   | Muffy    | 24  | Indore  | 10000.00 |

### INSERT

Подзаявките също могат да се използват с оператори INSERT. Операторът INSERT използва данните, върнати от подзаявката, за да ги вмъкне в друга таблица. Избраните данни в подзаявката могат да бъдат модифицирани с всяка от функциите за знаци, дати или числа.

```sql
INSERT INTO CUSTOMERS_BKP
   SELECT * FROM CUSTOMERS 
   WHERE ID IN (SELECT ID 
   FROM CUSTOMERS) ;
```

### UPDATE

Подзаявката може да се използва заедно с оператора UPDATE. Една или няколко колони в таблица могат да бъдат актуализирани, когато се използва подзаявка с израза UPDATE.

```sql
UPDATE CUSTOMERS
   SET SALARY = SALARY * 0.25
   WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP
      WHERE AGE >= 27 );
```

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 35  | Ahmedabad | 125.00   |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 2125.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

### DELETE

Подзаявката може да се използва заедно с оператора DELETE, както с всички други оператори, споменати по-горе.

```sql
DELETE FROM CUSTOMERS
   WHERE AGE IN (SELECT AGE FROM CUSTOMERS_BKP
      WHERE AGE >= 27 );
```

| ID  | NAME     | AGE | ADDRESS | SALARY   |
| --- | -------- | --- | ------- | -------- |
| 2   | Khilan   | 25  | Delhi   | 1500.00  |
| 3   | kaushik  | 23  | Kota    | 2000.00  |
| 4   | Chaitali | 25  | Mumbai  | 6500.00  |
| 6   | Komal    | 22  | MP      | 4500.00  |
| 7   | Muffy    | 24  | Indore  | 10000.00 |
## 9. Съединения на таблици
SQL `JOIN` съединява две таблици въз основа на обща колона и избира записи, които имат съвпадащи стойности в тези колони.

### Example

```sql
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
JOIN Orders
ON Customers.customer_id = Orders.customer;
```

---

### Типове SQL JOINs

Командата `JOIN` , която изпълнихме по-рано, е `INNER JOIN`. Има основно четири вида съединения.

-   INNER JOIN
-   LEFT JOIN
-   RIGHT JOIN
-   FULL OUTER JOIN

---

### SQL JOIN и псевдоними

Можем да използваме AS псевдоними с имена на таблици, за да направим нашия фрагмент кратък и чист. Например,

```sql
SELECT C.customer_id, C.first_name, O.amount
FROM Customers AS C
JOIN Orders AS O
ON C.customer_id = O.customer;
```
### SQL INNER JOIN

SQL `INNER JOIN` съединява две таблици въз основа на обща колона и избира записи, които имат съвпадащи стойности в тези колони.

#### Example

```sql
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
INNER JOIN Orders
ON Customers.customer_id = Orders.customer;
```
![How to use INNER JOIN in SQL](https://www.programiz.com/sites/tutorial2program/files/inner-join-in-sql.png "SQL INNER JOIN in SQL Example")

#### Синтаксиса на INNER JOIN

```sql
SELECT columns
FROM table1
INNER JOIN table2
ON table1.column_name = table2.column_name;
```

---

#### INNER JOIN със WHERE клауза

```sql
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
INNER JOIN Orders
ON Customers.customer_id = Orders.customer
WHERE Orders.amount >= 500;
```

Here, the SQL command joins two tables and selects rows where the amount is **greater than or equal to 500**.
### SQL LEFT JOIN

SQL `LEFT JOIN` съединява две таблици въз основа на обща колона и избира записи, които имат съвпадащи стойности в тези колони и останалите редове от лявата таблица.

#### Example

```sql
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
LEFT JOIN Orders
ON Customers.customer_id = Orders.customer;
```

![How to use LEFT JOIN in SQL](https://www.programiz.com/sites/tutorial2program/files/left-join-in-sql.png "SQL LEFT JOIN in SQL Example")

#### Синтаксис на LEFT JOIN

```sql
SELECT columns
FROM table1
LEFT JOIN table2
ON table1.column_name = table2.column_name;
```
### SQL RIGHT JOIN

SQL `RIGHT JOIN` съединява две таблици въз основа на обща колона и избира записи, които имат съвпадащи стойности в тези колони и останалите редове от дясната таблица.

#### Example

```sql
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
RIGHT JOIN Orders
ON Customers.customer_id = Orders.customer;
```
![How to use RIGHT JOIN in SQL](https://www.programiz.com/sites/tutorial2program/files/right-join-in-sql.png "SQL RIGHT JOIN in SQL Example")

#### Синтаксиса на RIGHT JOIN
```sql
SELECT columns
FROM table1
RIGHT JOIN table2
ON table1.column_name = table2.column_name;
```
### SQL FULL OUTER JOIN

SQL `FULL OUTER JOIN` съединява две таблици въз основа на обща колона и избира записи, които имат съвпадащи стойности в тези колони и останалите редове от двете таблици.

#### Example

```sql
SELECT Customers.customer_id, Customers.first_name, Orders.amount
FROM Customers
FULL OUTER JOIN Orders
ON Customers.customer_id = Orders.customer;
```
![How to use FULL OUTER JOIN in SQL](https://www.programiz.com/sites/tutorial2program/files/sql-full-outer-join.png "SQL FULL OUTER JOIN in SQL Example")
#### Синтаксиса на FULL OUTER JOIN
```sql
SELECT columns
FROM table1
FULL OUTER JOIN table2
ON table1.column_name = table2.column_name;
```
## 10. Агрегиращи функции и групиране на данни
#### **1. String Functions**
##### Length

Най-**простата** функция за SQL низ е дължината. Както подсказва името му, `length` връща броя знаци, които даден низ съдържа (включително интервали и препинателни знаци). Нека да разгледаме прост оператор за избор на PostgreSQL и да го захраним с низа „Здравей, името ми е“:
```sql
SELECT LENGHT('Hello, my name is');
```

Резултатът от изпълнението на тази заявка е 17. Ако ръчно преброите броя на знаците, включително интервалите, в горния низ, ще откриете, че 17 е точно съвпадение! Въпреки че „дължина“ може първоначално да изглежда като тривиална функция, всъщност ще я използвате много често.

##### Trim

Да намалим малко мазнините! Друг пример от категорията на най-полезните SQL функции е `trim`. Той елиминира **излишните** интервали и раздели от началото и края на низ, който предаваме като негов аргумент. Например, ако предадем низа „Здравей, името ми е“, ще получим същия низ, но без всички тези водещи и завършващи интервали. Ето една основна заявка с този низ:
```sql
SELECT TRIM('  Hello, my name is  ');
```


Както се очаква, горната заявка връща „Здравейте, казвам се“.

##### Concat

Функцията `concat` комбинира (**свързва**) два или повече низа, които предаваме като нейни аргументи. Ето пример за конкатенация на низове в действие:
```sql
SELECT CONCAT(' Hello, ','my name is ','Paul');
```

Тази заявка връща низа ``Здравейте, казвам се Пол``.

##### Upper

При даден низ, upper връща същия низ, но с всичките му знаци, превърнати в **главни букви**. Така че, ако искате всички да ви чуват силно и ясно, можете да напишете следната заявка:
```sql
SQLQCT UPPER('Hello, my name is Paul');
```

Това връща низа ``ЗДРАВЕЙТЕ, ИМЕТО МИ Е ПОЛ``.

##### Lower

Функцията `lower` е пряка противоположност на `upper` — тя взема низ и връща същия низ с всичките му символи, превърнати в **малки букви**. Ето една заявка, която използва по-ниски:
```sql
SELECT LOWER('Hello, my name is Paul');
```
Predictably, we get the string `'hello, my name is paul'`.
#### **2. NUMERICAL FUNCTIONS**
Числовите функции просто работят с числа и в тази категория има доста полезни SQL функции. Нека обсъдим няколко от тях.

##### Abs

Abs е съкращение за абсолютен; това е една от най-разпространените SQL функции, която изчислява **абсолютната стойност** на числова стойност, която предаваме като неин аргумент. С други думи, abs връща положителната версия на дадено число. Ето един пример:
```sql
SELECT ABS(-22),ABS(22);
```
Ако сте внимавали в часовете по математика, ще знаете, че и двете извиквания на abs връщат числото 22.

##### Round

Функцията `round` приема число с плаваща запетая (десетично) и го закръгля точно както бихте направили обикновено на хартия. Разгледайте този прост пример:
```sql
SELECT ROUND(5.4),ROUND(5.5),Round(5.6);
```

Ще получим съответно 5 (следващото най-малко цяло число), 6 (следващото най-голямо цяло число) и 6 (следващото най-голямо цяло число) за горните три извиквания на закръгляване.

##### Ceil

Функцията `ceil` връща **тавана** на число – първото цяло число, по-голямо или равно на това число. За да визуализирате този процес, поставете въпросното число (да кажем -0,5) на стандартен числов ред и се преместете отляво надясно, търсейки следващото най-голямо цяло число (в този случай това е 0). Ето още един пример:
```sql
SELECT CEIL(5.4),CEIL(5.5),CEIL(6);
```
Получаваме числата 6, 6 и 6 за тези три обаждания.

##### Floor

`Floor` е обратното на функцията `ceil` ; той връща дъното на десетичното число, което подаваме като негов аргумент — първото цяло число, което е по-малко или равно на това число. Например, подът от -0,5 е -1, тъй като това е първото цяло число, което е по-малко от -0,5. С визуализацията на числовата линия започвате от даденото число и се движите отдясно наляво в търсене на цяло число. Ако вместо това повторим горните извиквания с функцията `floor` :
```sql
SELECT FLOOR(5.4),FLOOR(5.5),FLOOR(6);
```
Получаваме тези три числа, след като изпълним горната заявка: 5, 5 и 6.
##### Greatest

Друга от най-полезните SQL функции, greatest, взема списък с изрази и връща **най-големия** от тях. Ето пример за използването му:
```sql
SELECT GREATEST(1,2,3,5,6);
```

Естествено, тази заявка връща 6, тъй като това е най-голямата стойност в списъка, който предоставихме.

##### Least

Най-малкото е пряко обратно на най-голямото. Ако напишем следната заявка:
```sql
SELECT LEAST(1,2,3,5,6);
```
Тази заявка връща 1, тъй като това е най-малката стойност в предоставения от нас списък.
## 11.  Филтриране и сортиране на групирани данни.
Транзакцията е единица работа, която се извършва срещу база данни. Транзакциите са единици или последователности от работа, извършени в логичен ред, независимо дали ръчно от потребител или автоматично от някакъв вид програма за база данни.

Транзакцията е разпространението на една или повече промени в базата данни. Например, ако създавате запис или актуализирате запис или изтривате запис от таблицата, тогава извършвате транзакция на тази таблица. Важно е да се контролират тези транзакции, за да се гарантира целостта на данните и да се обработват грешки в базата данни.

На практика ще групирате много SQL заявки в група и ще изпълните всички заедно като част от транзакция.

### Properties of Transactions

Транзакциите имат следните четири стандартни свойства, обикновено наричани с акронима **ACID**.

- **Атомарност** − гарантира, че всички операции в работната единица са завършени успешно. В противен случай транзакцията се прекъсва в точката на неуспех и всички предишни операции се връщат обратно към предишното им състояние.
- **Постоянство** − гарантира, че базата данни правилно променя състоянията при успешно извършена транзакция.
- **Изолация** – позволява транзакциите да работят независимо и прозрачно една за друга.
- **Устойчивост** − гарантира, че резултатът или ефектът от извършена транзакция продължава в случай на повреда на системата.

### Transaction Control

Следните команди се използват за контрол на транзакциите.

- **COMMIT** − за запазване на промените.
- **ROLLBACK** − за връщане назад на промените.
- **SAVEPOINT** – създава точки в рамките на групите от транзакции, в които да се ВЪРНЕ.
- **SET TRANSACTION** − Поставя име на транзакция.
### Transactional Control Commands

Командите за контрол на транзакциите се използват само с **DML командите** като например - INSERT, UPDATE и DELETE само. Те не могат да се използват, докато създавате таблици или ги премахвате, тъй като тези операции се извършват автоматично в базата данни.

### The COMMIT Command

Командата COMMIT е транзакционната команда, използвана за запазване на промените, извикани от транзакция в базата данни.

Командата COMMIT е транзакционната команда, използвана за запазване на промените, извикани от транзакция в базата данни. Командата COMMIT запазва всички транзакции в базата данни след последната команда COMMIT или ROLLBACK.

Синтаксисът за командата COMMIT е както следва.

```sql
COMMIT;
```

**Example**

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

Следва пример, който би изтрил тези записи от таблицата, които имат възраст = 25 и след това КОМИТ промените в базата данни.

```sql
DELETE FROM CUSTOMERS
   WHERE AGE = 25;
COMMIT;
```

Така два реда от таблицата ще бъдат изтрити и операторът SELECT ще доведе до следния резултат.

| ID  | NAME    | AGE | ADDRESS   | SALARY   |
| --- | ------- | --- | --------- | -------- |
| 1   | Ramesh  | 32  | Ahmedabad | 2000.00  |
| 3   | kaushik | 23  | Kota      | 2000.00  |
| 5   | Hardik  | 27  | Bhopal    | 8500.00  |
| 6   | Komal   | 22  | MP        | 4500.00  |
| 7   | Muffy   | 24  | Indore    | 10000.00 |

### The ROLLBACK Command

Командата ROLLBACK е транзакционната команда, използвана за отмяна на транзакции, които все още не са били записани в базата данни. Тази команда може да се използва само за отмяна на транзакции след последната команда COMMIT или ROLLBACK.

Синтаксисът за команда ROLLBACK е както следва -

```sql
ROLLBACK;
```

**Example**

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

```sql
DELETE FROM CUSTOMERS
   WHERE AGE = 25;
ROLLBACK;
```

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

### The SAVEPOINT Command

SAVEPOINT е точка в транзакция, когато можете да върнете транзакцията до определена точка, без да връщате назад цялата транзакция.

Синтаксисът за команда SAVEPOINT е както е показано по-долу.

```sql
SAVEPOINT SAVEPOINT_NAME;
```

Тази команда служи само за създаване на SAVEPOINT сред всички транзакционни отчети. Командата ROLLBACK се използва за отмяна на група транзакции.

Синтаксисът за връщане към SAVEPOINT е както е показано по-долу.

```sql
ROLLBACK TO SAVEPOINT_NAME;
```

Следва пример, в който планирате да изтриете трите различни записа от таблицата CUSTOMERS. Искате да създадете SAVEPOINT преди всяко изтриване, така че да можете да се върнете към която и да е SAVEPOINT по всяко време, за да върнете съответните данни в първоначалното им състояние.

**Example**
| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 32  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

```sql
SQL> SAVEPOINT SP1;
Savepoint created.
SQL> DELETE FROM CUSTOMERS WHERE ID=1;
1 row deleted.
SQL> SAVEPOINT SP2;
Savepoint created.
SQL> DELETE FROM CUSTOMERS WHERE ID=2;
1 row deleted.
SQL> SAVEPOINT SP3;
Savepoint created.
SQL> DELETE FROM CUSTOMERS WHERE ID=3;
1 row deleted.
```

Сега, след като трите изтривания са извършени, нека приемем, че сте променили решението си и сте решили да се върнете към ТОЧКАТА ЗА ЗАПАЗВАНЕ, която сте идентифицирали като SP2. Тъй като SP2 е създаден след първото изтриване, последните две изтривания се отменят −

```sql
ROLLBACK TO SP2;
```

| ID  | NAME     | AGE | ADDRESS | SALARY   |
| --- | -------- | --- | ------- | -------- |
| 2   | Khilan   | 25  | Delhi   | 1500.00  |
| 3   | kaushik  | 23  | Kota    | 2000.00  |
| 4   | Chaitali | 25  | Mumbai  | 6500.00  |
| 5   | Hardik   | 27  | Bhopal  | 8500.00  |
| 6   | Komal    | 22  | MP      | 4500.00  |
| 7   | Muffy    | 24  | Indore  | 10000.00 |

### The RELEASE SAVEPOINT Command

Командата RELEASE SAVEPOINT се използва за премахване на SAVEPOINT, който сте създали.

Синтаксисът за команда RELEASE SAVEPOINT е както следва.

```sql
RELEASE SAVEPOINT SAVEPOINT_NAME;
```

След като SAVEPOINT бъде освободена, вече не можете да използвате командата ROLLBACK за отмяна на транзакции, извършени след последната SAVEPOINT.

### The SET TRANSACTION Command
Командата SET TRANSACTION може да се използва за иницииране на транзакция на база данни. Тази команда се използва за указване на характеристики за транзакцията, която следва. Например, можете да зададете транзакция да бъде само за четене или за четене и запис.

---
### Functions
Самостоятелна функция се създава с помощта на оператора **CREATE FUNCTION**. Опростеният синтаксис за оператора **CREATE OR REPLACE PROCEDURE** е както следва −

```sql
CREATE [OR REPLACE] FUNCTION function_name 
[(parameter_name [IN | OUT | IN OUT] type [, ...])] 
RETURN return_datatype 
{IS | AS} 
BEGIN 
   < function_body > 
END [function_name];
```

Където,

- _function-name_ указва името на функцията.
- Опцията [OR REPLACE] позволява промяна на съществуваща функция.
- Списъкът с параметри по избор съдържа име, режим и типове на параметрите. IN представлява стойността, която ще бъде предадена отвън, а OUT представлява параметъра, който ще се използва за връщане на стойност извън процедурата.
- Функцията трябва да съдържа оператор **return** .
- Клаузата _RETURN_ указва типа данни, които ще върнете от функцията.
- _function-body_ съдържа изпълнимата част.
- Ключовата дума AS се използва вместо ключовата дума IS за създаване на самостоятелна функция.

```sql
CREATE OR REPLACE FUNCTION totalCustomers 
RETURN number IS 
   total number(2) := 0; 
BEGIN 
   SELECT count(*) into total 
   FROM customers; 
    
   RETURN total; 
END;
```

---
### Stored procedure

ID  NAME       AGE       ADDRESS            SALARY 
1   Ramesh     32        Ahmedabad          2000.00 
2   Khilan     25        Delhi              1500.00 
3   kaushik    23        Kota               2000.00 
4   Chaitali   25        Mumbai             6500.00 
5   Hardik     27        Bhopal             8500.00 
6   Komal      22        MP                 4500.00 
7   Muffy      24        Indore             10000.00 

```sql
CREATE PROCEDURE SelectCustomerstabledata 
AS 
SELECT * FROM Testdb.Customers 
GO
```

ID  NAME       AGE       ADDRESS           SALARY 
1   Ramesh     32        Ahmedabad         2000.00 
2   Khilan     25        Delhi             1500.00 
3   kaushik    23        Kota              2000.00 
4   Chaitali   25        Mumbai            6500.00 
5   Hardik     27        Bhopal            8500.00 
6   Komal      22        MP                4500.00 
7   Muffy      24        Indore            10000.00


By Калоян Динев