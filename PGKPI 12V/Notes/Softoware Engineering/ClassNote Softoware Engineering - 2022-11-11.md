---
tags: [classnote, SE, template]
creation date: 2022-11-11 18:15
modification date: 2022-11-11 18:15
---

Links: [[Software Engineering - Main]]
```button
name Go Back
type link
action obsidian://open?vault=PGKPI%2012V&file=Index
```
# ClassNote - Softoware Engineering
2022-11-11

1.  Въведение в базите от данни. 
2.  Типове данни. 
3.  Основни команди.
4.   Основни SQL команди за работа с бази данни – създаване, промяна и премахване на бази от данни, таблици и колони. 
5.  Моделиране на релационни бази от данни – нормализация и нормални форми. 
6.  Типове връзки, каскадни операции и ограничения. 
7.  Заявки за извличане и промяна на данни (SELECT, INSERT, UPDATE, DELETE). 
8.  Сложни заявки за извличане на данни. 
9.  Съединения на таблици (SQL JOIN). 
10.   Агрегиращи функции и групиране на данни. 
11.  Филтриране и сортиране на групирани данни. Функции, транзакции и съхранени процедури.
# Notes
## 1. Въведение в базите от данни. 
**а) База от данни**

> Базата данни е организирана колекция от структурирана информация или данни, обикновено съхранявани електронно в компютърна система. Базата данни обикновено се управлява от система за управление на база данни (СУБД).

> Данните обикновено се моделират в редове и колони в поредица от таблици, за да направят обработката и заявките за данни ефективни. След това данните могат да бъдат лесно достъпни, управлявани, модифицирани, актуализирани, контролирани и организирани. Повечето бази данни използват структуриран език за заявки (SQL) за писане и заявяване на данни.

**б) SQL**

> SQL е език за програмиране, използван от почти всички релационни бази данни за заявки, манипулиране и дефиниране на данни.

**в) Типове база данни**

- Релационна

> Елементите в релационна база данни са организирани като набор от таблици с колони и редове. Технологията за релационни бази данни осигурява най-ефективния и гъвкав начин за достъп до структурирана информация.


- Нерелационна

> NoSQL или нерелационна база данни позволява неструктурирани и полуструктурирани данни да бъдат съхранявани и манипулирани (за разлика от релационна база данни, която определя как трябва да бъдат съставени всички данни, вмъкнати в базата данни).

## 2. Типове данни
Глваните типове данни в една релационна база данни са:
**а) Низови типове данни**
- char
- varchar
- nchar
- nvarchar
- binary
- varbinary
- image

**б) Номерични типове данни**

- bit
- tinyint
- smallint
- bigint
- decimal(p,s)
- money
- float
- real

**в) Времеви типове данни**

- datetime
- datetime2
- date
- time
- datetimeoffset
- timestamp
## 3. Основни команди.
> Езикът за дефиниране на данни или DDL командите на структорираният език за заявки (SQL) се използват за описание/дефиниране на схемата на базата данни. Тези команди се занимават със създаването на схема на база данни и нейните допълнителни модификации. Някои популярни DDL команди са CREATE, ALTER, DROP, TRUNCATE

> Командите на езика за манипулиране на данни (DML) в SQL се занимават с манипулиране на записи на данни, съхранявани в таблиците на базата данни. Той не се занимава с промени в обектите на базата данни и нейната структура. Общоизвестните DML команди са INSERT, UPDATE, DELETE, SELECT.

##  4. Основни SQL команди за работа с бази данни
### 4.1. DDL

| Command  | Description                                                                                   |
| -------- | --------------------------------------------------------------------------------------------- |
| CREATE   | Използва се за създаване на обекти на база данни като база данни и таблица на база данни.     |
| ALTER    | Използва се за модифициране и преименуване на елементи от съществуваща таблица на база данни. |
| DROP     | Използва се за премахване на цяла база данни или таблица на база данни.                       |
| TRUNCATE | Използва се за премахване на всички записи от таблица на база данни.                          |

#### 1. CREATE

> CREATE е команда за език за дефиниране на данни (DDL), която се използва за създаване на обекти на база данни, като база данни и таблица на база данни.

Синтаксисът за създаване на база данни е както следва:

```sql
CREATE DATABASE database_name;
```

Основният синтаксис за създаване на таблица в SQL е както следва:

```sql
CREATE TABLE public.customers  
(  
column_name_1  datatype [NULL | NOT NULL],  
column_name_2  datatype [NULL | NOT NULL],  
.  
.  
.  
column_name_n  datatype [NULL | NOT NULL] )
```

#### 2. ALTER

> Командата ALTER в SQL се използва за добавяне, преименуване или модифициране, премахване/изтриване на колони в съществуваща таблица на база данни. Освен това може да се използва за добавяне и премахване на различни ограничения върху съществуваща таблица на база данни.

Синтаксисът, използван за промяна на таблица в SQL чрез добавяне на нова колона, е както следва:
```sql
ALTER TABLE table_name   ADD (Columnname_1  datatype)
```

Синтаксисът, използван за преименуване на таблица, е както следва:

```cs
ALTER TABLE table_name_1   RENAME TO table_new_name;
```


Синтаксисът, използван за промяна на таблица в SQL чрез изтриване на съществуващи колони, е както следва:

```cs
ALTER TABLE table_name   DROP columnname_1 , columnname_2, ...
```

#### 3. TRUNCATE

> Командата TRUNCATE TABLE се използва за премахване на всички записи на данни от таблицата на базата данни. Той изтрива всички редове за постоянно. Следователно, не можем да извършим операция за връщане назад, за да отменим команда TRUNCATE.

Общият синтаксис, използван за писане на команда TRUNCATE, е както следва:
```sql
TRUNCATE TABLE table_name;
```


#### 4. DROP

> Командата DROP TABLE в SQL се използва за изтриване на обект на база данни от базата данни. Можем дори да изтрием базата данни с помощта на командата DROP. Не можем да извършим операция за връщане назад, за да отменим команда DROP база данни/таблица.

Основният синтаксис за писане на команда DROP за изтриване на база данни в SQL е както следва:

```sql
DROP DATABASE database_name;
```



Синтаксисът за писане на команда DROP за изтриване на база данни в SQL е както следва:

```sql
DROP TABLE table_name;
```

### 4.2. DML

| Command | Description                                                                           |
| ------- | ------------------------------------------------------------------------------------- |
| SELECT  | Използва се за извличане на избрани полета или колони от таблица на база данни        |
| INSERT  | Използва се за вмъкване на нови записи с данни или редове в таблицата на базата данни |
| UPDATE  | Използва се за задаване на нова стойност на поле или колона за определен запис        |
| DELETE  | Използва се за премахване на един или повече редове от таблицата на базата данни      |

#### 1. SELECT

> Командата или изразът SELECT в SQL се използва за извличане на записи с данни от таблицата на базата данни и представянето им под формата на набор от резултати. Обикновено се счита за DQL команда, но може да се разглежда и като DML.

Синтаксисът за писане на оператор UPDATE е както следва:

```sql
SELECT column_name1, column_name2, …  
FROM table_name  
WHERE condition_ expression;
```

Параметрите, използвани в горния синтаксис, са както следва:

-   **column_name1, column_name2, … :** Посочете имената на колони, които трябва да бъдат извлечени или избрани за крайния набор от резултати.
-   **table_name:** Посочете името на таблицата на базата данни, от която тези резултати трябва да бъдат извлечени.
-   **condition_expression:** Задайте израза на условието за филтриране на записи за крайния набор от резултати.

#### 2. INSERT

> Командите INSERT в SQL се използват за вмъкване на записи с данни или редове в таблица на база данни. В оператор INSERT ние указваме както имената на колони, за които трябва да се направи запис, така и стойността на данните, която трябва да бъде вмъкната.

Основният синтаксис за писане на оператори INSERT в SQL е както следва:

```sql
INSERT INTO table_name (column_name_1, column_name_2, column_name_3, ...)  
VALUES (value1, value2, value3, ...)
```

Под VALUES, имаме предвид стойността на съответните колони.

#### 3. UPDATE

> Командата UPDATE се използва за промяна на стойността на съществуваща колона в таблица на база данни.

Синтаксисът за писане на оператор UPDATE е както следва:

```sql
UPDATE table_name  
SET column_name_1 = value1, column_name_2 = value2, ...  
WHERE condition;
```

#### 4. DELETE

> Командата DELETE в SQL се използва за премахване на един или повече редове от таблицата на базата данни. Той не изтрива записите с данни за постоянно. Винаги можем да извършим операция за връщане назад, за да отменим команда DELETE. С операторите DELETE можем да използваме клаузата WHERE за филтриране на конкретни редове.

Синтаксисът за писане на оператор DELETE е както следва:

```sql
DELETE FROM table_name WHERE condition;
```

## 5. Моделиране на релационни бази от данни
> Нормализирането на базата данни е процес на организиране на данни в таблици по такъв начин, че резултатите от използването на базата от данни да са винаги недвусмислени и по предназначение. Такава нормализация е присъща на теорията за релационните бази данни. Това може да има ефект на дублиране на данни в базата данни и често води до създаване на допълнителни таблици.

Степените на нормализиране на таблиците на релационни бази данни са дефинирани и включват:

**Първа нормална форма (1NF).** 
Това е "основното" ниво на нормализиране на базата данни и обикновено съответства на дефиницията на всяка база данни, а именно:

> Съдържа двумерни таблици с редове и колони. Всяка колона съответства на подобект или атрибут на обекта, представен от цялата таблица.Всеки ред представлява уникален екземпляр на този подобект или атрибут и трябва да се различава по някакъв начин от всеки друг ред (т.е. не са възможни дублиращи се редове). 
> Всички записи във всяка колона трябва да са от един и същи вид. Например в колоната с етикет „Клиент“ са разрешени само имена или номера на клиенти.

**Втора нормална форма (2NF).** 
> При това ниво на нормализиране всяка колона в таблица, която не е определяща за съдържанието на друга колона, сама трябва да бъде функция на другите колони в таблицата. Например в таблица с три колони, съдържаща идентификационния номер на клиента, продадения продукт и цената на продукта при продажба, цената ще бъде функция на идентификационния номер на клиента (с право на отстъпка) и конкретния продукт. В този случай се казва, че данните в третата колона зависят от данните в първата и втората колона. Тази зависимост не се среща в случая 1NF.

> Колоната, означена като идентификатор на клиента, се счита за първичен ключ, тъй като това е колона, която уникално идентифицира редовете в тази таблица и отговаря на другите приети изисквания в стандартната схема за управление на база данни: тя няма NULL стойности и нейните стойности няма да се променят с течение на времето.

> В примера по-горе другите заглавки на колони се считат за кандидат ключове. Атрибутите на тези кандидат ключове, които ги правят уникални, се наричат основни атрибути.

**Трета нормална форма (3NF).** 
> Във втората нормална форма все още са възможни модификации, тъй като промяна в един ред в таблица може да засегне данните, които препращат към тази информация от друга таблица. Например, използвайки току-що цитираната таблица с клиенти, премахването на ред, описващ клиентска покупка (може би поради връщане), също ще премахне факта, че продуктът има определена цена. В третата нормална форма тези таблици ще бъдат разделени на две таблици, така че ценообразуването на продукта да се проследява отделно.


## 6. Типове връзки, каскадни операции и ограничения.
Всяко свързване между два типа обекти се нарича връзка. Субектите участват във връзката. Представен е с форма на диамант.

> Имаме два типа обекти „Клиент“ (Customer_id, Име, Град, Телефон) и „Акаунт“ (Account_no, Тип, Баланс). Съхраняваме данните на „Клиент“ в една таблица и данните за неговите сметки в таблицата „Акаунт“. Сега, за да свържем тези две таблици, трябва да вмъкнем първичния ключ „Customer_id“ на таблицата „Customer“ в таблицата „Account“. Този ключ действа като външен ключ за таблицата „Акаунт“ и препраща към колона със същото име в таблицата „Клиент“. Така се установява връзка между две таблици. Има три вида връзки, които могат да съществуват между два обекта.

- Връзка едно към едно
- Връзка "един към много" или "много към едно".
- Връзка много към много

### One-to-One Relationship

Такава връзка съществува, когато всеки запис от една таблица е свързан само с един запис от другата таблица.

> **_Например,_** Ако има два обекта „Лице“ (Id, Име, Възраст, Адрес) и „Паспорт“ (Passport_id, Passport_no). Така че всеки човек може да има само един паспорт и всеки паспорт принадлежи само на един човек.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-one-to-one-relationship-example-e89f4cf71cbaee76.jpg)

> Подобна връзка не е много често срещана. Такава връзка обаче се използва за целите на сигурността. В горния пример можем лесно да съхраним идентификатора на паспорта само в таблицата „Лице“. Но ние правим друга таблица за „Паспорт“, тъй като номерът на паспорта може да е чувствителна информация и трябва да бъде скрит от определени потребители. Така че, като направим отделна таблица, ние осигуряваме допълнителна сигурност, която само определени потребители на базата данни могат да я видят.

### One-to-Many or Many-to-One Relationship

> Такава връзка съществува, когато всеки запис от една таблица може да бъде свързан с един или повече от един запис от другата таблица. Тази връзка е най-често срещаната връзка. Връзката "един към много" може също да се каже като връзка "много към едно", в зависимост от начина, по който я разглеждаме.

> **_Например,_** Ако има два типа обекти „Клиент“ и „Акаунт“, тогава всеки „Клиент“ може да има повече от един „Акаунт“, но всеки „Акаунт“ се държи само от един „Клиент“. В този пример можем да кажем, че всеки клиент е свързан с много акаунти. Така че това е връзка "един към много". Но ако го видим по друг начин, т.е. много акаунти са свързани с един клиент, тогава можем да кажем, че това е връзка много към едно.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-one-to-many-relationship-example-0d5c065e28b4f23a.jpg)

### Many-to-Many Relationship

> Такава връзка съществува, когато всеки запис от първата таблица може да бъде свързан с един или повече от един запис от втората таблица и единичен запис от втората таблица може да бъде свързан с един или повече от един запис от първата таблица. Връзка много към много може да се разглежда като две релации едно към много, които са свързани чрез „свързваща таблица“ или „асоциирана таблица“. Свързващата таблица свързва две таблици, като има полета, които са първичен ключ на другите две таблици. Можем да разберем това със следния пример.

**Пример:** Ако има два типа обекти „Клиент“ и „Продукт“, тогава всеки клиент може да купи повече от един продукт и един продукт може да бъде закупен от много различни клиенти.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-many-to-many-relationship-example-bd4be3b525b7bdcd.jpg)

> Сега, за да разберем концепцията на свързващата таблица тук, можем да имаме обекта „Поръчка“ като свързваща таблица, която свързва обекта „Клиент“ и „Продукт“. Можем да прекъснем тази връзка много към много в две връзки едно към много. Първо, всеки „Клиент“ може да има много „Поръчки“, докато всяка „Поръчка“ е свързана само с един „Клиент“. Второ, всяка „Поръчка“ е свързана само с един продукт, където може да има много поръчки за един и същ продукт.

![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-are-the-different-types-of-relationships-in-dbms-many-to-many-relationship-examples-c961b29d4c8aa6a5.jpg)

> В горната концепция за свързване може да се разбере с помощта на вземане под внимание на всички атрибути на обектите „Клиент“, „Поръчка“ и „Продукт“. Можем да видим, че първичният ключ на обекта „Клиент“ и „Продукт“ са включени в таблицата за свързване, т.е. таблицата „Поръчка“. Тези ключове действат като външни ключове, докато препращат към съответната таблица от таблицата "Поръчка".

---
### Каскадни операции

> CASCADE в SQL се използва за едновременно изтриване или актуализиране на запис от дъщерната и родителската таблица. Ключовата дума CASCADE се използва като връзка при писане на заявката за ON DELETE или ON UPDATE. Ако ключовата дума cascade се добави към заявка, написана за родителската таблица, тогава и родителската, и дъщерната таблица се променят съответно при изпълнението на заявката.

> Да предположим, че сме създали две таблици с ВЪНШЕН КЛЮЧ във връзка с външен ключ, което прави и двете таблици родител и дете. След това дефинираме клауза ON DELETE CASCADE за един FOREIGN KEY, който трябва да бъде зададен, за да може другият да успее в каскадните операции. Ако ON DELETE CASCADE е дефинирана само за една клауза FOREIGN KEY, тогава каскадните операции ще изведат грешка.

```sql
FOREIGN KEY (emp_id) REFERENCES Employee (emp_id) ON DELETE CASCADE
```

>Клаузата ON UPDATE CASCADE се използва за **актуализиране** на съвпадащите записи от дъщерната таблица автоматично, когато актуализираме редовете в родителската таблица. Следващият пример го обяснява по-ясно.

```sql
ALTER TABLE Payment ADD CONSTRAINT `payment_fk`   
FOREIGN KEY(emp_id) REFERENCES Employee (emp_id) ON UPDATE CASCADE;
```

---
### Ограничения

В таблица на база данни можем да добавим правила към колона, известна като **ограничения**. Тези правила контролират данните, които могат да се съхраняват в колона.

Например, ако колона има ограничение `NOT NULL` , това означава, че колоната не може да съхранява стойности `NULL`.

Ограниченията, използвани в SQL са:

| Constraint   | Description                         |
|--------------|-------------------------------------|
| NOT NULL     | values cannot be null               |
| UNIQUE       | values cannot match any older value |
| PRIMARY KEY  | used to uniquely identify a row     |
| FOREIGN KEY  | references a row in another table   |
| CHECK        | validates condition for new value   |
| DEFAULT      | set default value if not passed     |
| CREATE INDEX | used to speedup the read process    |


**Забележка:** Тези ограничения се наричат още ограничения за интегритет.

---
#### NOT NULL Constraint

Ограничението `NOT NULL` в колона означава, че колоната не може да съхранява `NULL` стойности. Например,

```
CREATE TABLE Colleges (
  college_id INT NOT NULL,
  college_code VARCHAR(20) NOT NULL,
  college_name VARCHAR(50)
);
```

---

#### UNIQUE Constraint

Ограничението `UNIQUE` в колона означава, че колоната трябва да има уникална стойност. Например,

```
CREATE TABLE Colleges (
  college_id INT NOT NULL UNIQUE,
  college_code VARCHAR(20) UNIQUE,
  college_name VARCHAR(50)
);
```


---

#### PRIMARY KEY Constraint

Ограничението `PRIMARY KEY` е просто комбинация от `NOT NULL` и `UNIQUE` ограничения. Това означава, че стойността на колоната се използва за уникално идентифициране на реда. Например,

```
CREATE TABLE Colleges (
  college_id INT PRIMARY KEY,
  college_code VARCHAR(20) NOT NULL,
  college_name VARCHAR(50)
);
```


---

#### FOREIGN KEY Constraint

Ограничението `FOREIGN KEY` (`REFERENCES` в някои бази данни) в колона се използва за препратка към запис, който съществува в друга таблица. Например,

```
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  customer_id int REFERENCES Customers(id)
);
```


---

#### CHECK Constraint

Ограничението `CHECK` проверява условието, преди да разреши стойности в таблица. Например,

```
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  amount int CHECK (amount >= 100)
);
```


---

#### DEFAULT Constraint

Ограничението `DEFAULT` се използва за задаване на стойността по подразбиране, ако се опитаме да съхраним `NULL` в колона. Например,

```
CREATE TABLE College (
  college_id INT PRIMARY KEY,
  college_code VARCHAR(20),
  college_country VARCHAR(20) DEFAULT 'US'
);
```
## 7. Заявки за извличане и промяна на данни
## 8. Сложни заявки за извличане на данни.
> Подзаявка или вложена заявка е заявка в рамките на друга SQL заявка и е вградена в клаузата WHERE. Подзаявка се използва за връщане на данни, които ще бъдат използвани в основната заявка като условие за допълнително ограничаване на данните, които трябва да бъдат извлечени. Подзаявките могат да се използват с операторите SELECT, INSERT, UPDATE и DELETE заедно с операторите като =, <, >, >=, <=, IN, BETWEEN и т.н.


- Подзаявките трябва да бъдат оградени в скоби.
- Една подзаявка може да има само една колона в клаузата SELECT, освен ако в основната заявка има няколко колони за подзаявката, за да сравни избраните колони.
- Команда ORDER BY не може да се използва в подзаявка, въпреки че основната заявка може да използва ORDER BY. Командата GROUP BY може да се използва за изпълнение на същата функция като ORDER BY в подзаявка.
- Подзаявки, които връщат повече от един ред, могат да се използват само с оператори с множество стойности, като оператор IN.
- Списъкът SELECT не може да включва препратки към стойности, които се оценяват на BLOB, ARRAY, CLOB или NCLOB.
- Подзаявка не може да бъде незабавно затворена в зададена функция.
- Операторът BETWEEN не може да се използва с подзаявка. Операторът BETWEEN обаче може да се използва в подзаявката.

### Example

Имаме таблицата Customers

| ID  | NAME     | AGE | ADDRESS   | SALARY   |
| --- | -------- | --- | --------- | -------- |
| 1   | Ramesh   | 35  | Ahmedabad | 2000.00  |
| 2   | Khilan   | 25  | Delhi     | 1500.00  |
| 3   | kaushik  | 23  | Kota      | 2000.00  |
| 4   | Chaitali | 25  | Mumbai    | 6500.00  |
| 5   | Hardik   | 27  | Bhopal    | 8500.00  |
| 6   | Komal    | 22  | MP        | 4500.00  |
| 7   | Muffy    | 24  | Indore    | 10000.00 |

```sql
SELECT * 
FROM CUSTOMERS 
WHERE ID IN (SELECT ID 
    FROM CUSTOMERS 
    WHERE SALARY > 4500) ;
```

Това ще е резултата

| ID  | NAME     | AGE | ADDRESS | SALARY   |
| --- | -------- | --- | ------- | -------- |
| 4   | Chaitali | 25  | Mumbai  | 6500.00  |
| 5   | Hardik   | 27  | Bhopal  | 8500.00  |
| 7   | Muffy    | 24  | Indore  | 10000.00 |

## 9. Съединения на таблици
SQL Server основно поддържа **четири типа JOINS** и всеки тип свързване определя как две таблици са свързани в заявка.

1.  INNER JOIN
2.  SELF JOIN
3.  CROSS JOIN
4.  OUTER JOIN

### INNER JOIN

Този JOIN връща всички записи от множество таблици, които отговарят на определеното условие за присъединяване. Това е най-простата и най-популярна форма на присъединяване и се приема като **присъединяване по подразбиране**. Ако пропуснем ключовата дума INNER със заявката JOIN, ще получим същия резултат.

Следното визуално представяне обяснява как INNER JOIN връща съответстващите записи от **table1** и **table2:**

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins2.png)

**INNER JOIN Example**
**Table: Student**

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins3.png)

**Table: Fee**

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins4.png)
```sql
SELECT 
Student.admission_no, Student.first_name, Student.last_name, Fee.course, Fee.amount_paid  
FROM Student  
INNER JOIN Fee  
ON Student.admission_no = Fee.admission_no;  
```

Тази команда дава следния резултат:

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins5.png)

### OUTER JOIN

OUTER JOIN в SQL Server **връща всички записи от двете таблици**, които отговарят на условието за присъединяване. С други думи, това обединяване няма да върне само съвпадащия запис, но също така ще върне всички несъвпадащи редове от една или и двете таблици.

**Можем да категоризираме OUTER JOIN допълнително в три типа:**
-   LEFT OUTER JOIN
-   RIGHT OUTER JOIN
-   FULL OUTER JOIN

#### LEFT OUTER JOIN

LEFT OUTER JOIN **извлича всички записи от лявата таблица и съвпадащите редове от дясната таблица**. Той ще върне **NULL** когато в дясната странична таблица не бъде намерен съответстващ запис. Тъй като OUTER е незадължителна ключова дума, тя е известна също като LEFT JOIN.

Визуалното представяне по-долу илюстрира LEFT OUTER JOIN:

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins9.png)

**Example**

```sql 
SELECT 
Student.admission_no, Student.first_name, Student.last_name, Fee.course, Fee.amount_paid  
FROM Student  
LEFT OUTER JOIN Fee  
ON Student.admission_no = Fee.admission_no;  
```

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins10.png)

#### RIGHT OUTER JOIN

RIGHT OUTER JOIN **извлича всички записи от дясната таблица и съответстващите редове от лявата таблица**. Той ще върне **NULL** когато в лявата таблица не бъде намерен съответстващ запис. Тъй като OUTER е незадължителна ключова дума, тя е известна също като RIGHT JOIN.

Визуалното представяне по-долу илюстрира RIGHT OUTER JOIN:

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins11.png)

**Example**

```sql
SELECT 
Student.admission_no, Student.first_name, Student.last_name, Fee.course, Fee.amount_paid  
FROM Student  
RIGHT OUTER JOIN Fee  
ON Student.admission_no = Fee.admission_no;  
```

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins12.png)

#### FULL OUTER JOIN

The FULL OUTER JOIN in SQL Server **returns a result that includes all rows from both tables**. The columns of the right-hand table return NULL when no matching records are found in the left-hand table. And if no matching records are found in the right-hand table, the left-hand table column returns NULL.

The below visual representation illustrates the FULL OUTER JOIN:

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins13.png)

**Example**

```sql
SELECT 
Student.admission_no, Student.first_name, Student.last_name, Fee.course, Fee.amount_paid  
FROM Student  
FULL OUTER JOIN Fee  
ON Student.admission_no = Fee.admission_no;  
```

![SQL Server JOINS](https://static.javatpoint.com/sqlserver/images/sql-server-joins14.png)

## 10. Агрегиращи функции и групиране на данни
## 11.  Филтриране и сортиране на групирани данни. 