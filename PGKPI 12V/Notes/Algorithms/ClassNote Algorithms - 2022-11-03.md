---
tags: [classnote, subject, template]
creation date: 2022-11-03 08:59
modification date: 2022-11-03 08:59
---

Links: [[Index]]
```button
name Go Back
type link
action obsidian://open?vault=PGKPI%2012V&file=Index
```
# ClassNote - Algorithms
2022-11-03

Изчисления, линейни, разклонени и циклични алгоритми
# Notes
## 1. Дефиниция на основни понятия
**a) Програмиране** 
> Програмирането е процеса, по който един програмист задава указания на компютъра. Тоест компютъра изпълнява това, което програмиста каже. Комютъра сам по себе си е безполезен. Той трябва да бъде инструктиран какво да прави. Пример: програмиста трябва да сметне 4+5. Той задава на компютъра каква операция се извършва и какви са числата. След като компютъра изчисли задачата, той връща резултата.

**б) Програмен език**
> Програмният език е среството, което пограмиста използва, за да зададе какви команди да изпълнява компютъра. Той взима кода, който е написан от програмиста и го трансформира в манишинни инструкции, които компютъра може да рзбере и евентуално изпълни. 

Всеки програмен език се състои от 4 оснони концепции
- Променливи

> Всяка променлива може да складира стойност като `12` или`"Hello World!"`. Единични променливи пазят единични стойности. Пример за единични применливи са `int`, `float`, `double`, `char`, `bool`. Начина, по който пазим повече от един блок онформация в една променлива е чрез масиви. Масивите могат да пазят много информация от един и същи тип

```cs
int number = 12;

// int представлява титъп на запазените данни. Int пази числа, double и float пазят реални числа, char пази единични букви, a bool пази стойснотите 0 и 1, които се транслират като false и true.
// number е името на променливата
// 12 е стойността запазена в променливата number
```

- Условни структури (Conditions)

> Условни структури или `if` и switch, за който ще споменм малко по-къзно, операторите предоставят възможността на една програма да взима различни решения, спрямо различни данни. If оператора се състой от следните ключови думи: `if`, `else if`, `else`. Важно е да се отбележи че винаги се започва първо с `if` после, ако има добълнително условие, `else if` и накрая `else`, ако имаме крайно условие.

> Основните сравнителни операции, които може да се изпълняват са следните: по-малко `<`, по-малко или равно `<=`, по-голямо `>`, по-голямо или равно `>=`, равно, различно  `!=`
```cs
if(16/2 == 8) // Проверяваме дали 16/2 = 8
{ // Този код се изпълнява само ако 16/2 = 8
	print("16/2 = 8")
}
else
{ // Този код се изпълнява само ако 16/2 не е равно на 8
	print("16/2 != 8")
}
```
- Структори от данни

>  Структори от данни е множоство от алгоритми, които се използват за организиране на данни в паметта

- Синтакс

> Синтаксисът е набор от правила, които определят какво означават различните комбинации от символи. Това казва на компютъра как да чете кода. Синтаксисът се отнася до концепция при писане на код, който се занимава с много специфичен набор от думи и много специфичен ред на тези думи, когато даваме инструкции на компютъра.

**в) Програмните езици се делят на много категории**

- Нисък и висок.

> Един език е нисък когато той оперира на ниско ниво. Тоест програмиста има възможността да менежира хардуера като например алокиране и делокиране на временната памет. Тоест езика няма никаква абстакция от машинният код на процесора. Пример: `x86 assembly`. С ниски езици се програмират вградени системи, операционни системи и тн.
> 
> Един език е висок когато той оперира на високо ниво. Тоест той предоставя абстакция от машинният код на един компютър следователно програмиста не трябва да се занимава с менежиране на хардуер. Пример: `C#, Java, Phyton`. С високи езици се създават десктопни апликации, уеб апликации и тн.

- Функционален и обектно ориентиран

> Един език е функционален ако логиката на приложението се описва във чисти математически функции. Пример за такъва езици са `C`, `Haskel`,`C++`. C++ е изключение защото той е и функционален така и обектно ориентиран.
```cs
int sum (int a,int b)
{
	return a+b;
}
// int е връщаната стойност на функцията
// sum е името на функцията
// int a,b са аргументите и от какъв тип са те
// a+b събира стойностите на аргументите a и b
// return връща получената стойност


int c = sum(4,5) // Променливата c присвоява върнатата стойност на метода sum()
```

> Един език е обектно ориентиран когато логиката на дадена програма се описва в класове. Класовете са обекти, които се стремят към абстракциране и енкапсулиране на логигата на една програма.

Основните компоненти на обектното ориентирано програмиране за 4.
- Енкапсулация

> В обектното ориентирано програмиране ние капсулираме чрез обвързване на данните и функциите, които оперират с тези данни в една единица, известна като клас. Това скрива частните детайли на класа от външния свят и разкрива само функционалност, важна за взаимодействие с него. Когато даден клас не позволява директен достъп на извикващия код до личните си данни, казваме, че е добре капсулиран.

- Абстракция

> Този процес се нарича „абстракция“ , защото ние абстрахираме детайлите на изпълнението на класа и представяме само чист, лесен за използване интерфейс чрез функциите-членове на класа. Внимателно използвана, абстракцията помага да се изолира въздействието на промените, направени в кода, така че ако нещо се обърка, промяната ще засегне само детайлите на изпълнението на клас, а не външния код.

- Наследяване

>Класовете могат да бъдат организирани в йерархии, където класът може да има един или повече родителски или дъщерни класове. Ако даден клас има родителски клас, ние казваме, че той е извлечен или наследен от родителския клас и представлява връзка тип „IS-A“. С други думи, дъщерният клас „IS-А“ тип на родителския клас. Следователно, ако даден клас наследява от друг клас, той автоматично получава голяма част от същата функционалност и свойства от този клас и може да бъде разширен, за да съдържа отделен код и данни. Хубава характеристика на наследяването е, че често води до добро повторно използване на кода, тъй като функциите на родителския клас не е необходимо да бъдат предефинирани в който и да е от неговите дъщерни класове.

- Полиморфизъм

> В ООП полиморфизмът позволява еднакво третиране на класове в йерархия. Следователно извикващият код трябва да бъде написан само за обработка на обекти от корена на йерархията и всеки обект, създаден от който и да е дъщерен клас в йерархията, ще бъде обработен по същия начин.

Класовете се състоят от 3 основни компонента

- Методи(член-функции) и полета

> Методите или член функциите са мястото където се описва главната функционалност на класа. Полетата са данните върху, които методите оперират

- Конструктори

> Конструкторът на клас е специален метод, който се извиква, когато даден клас се инстанцира с помощта на функцията NEW. Конструкторът за клас има същото име като името на класа. За разлика от обикновените методи, дефиницията на конструктора няма тип за връщане. Има 2 вида конструктура: с параметри и без. Един клас може да има повече от един конструктор. Ако класа няма конструктор, класа си създава сам. Ако добавим `~` пред имате на конструктура получаваме деструктор. Той се извиква, когато инстанцията на класа се изтрие.

- Достъпни модификатори

> Достъпните модификатори са 3 типа: `public`, `private`, `protected`. Public означава ще методите или полетата са достъпни извън класа. Private означава ще методите или полетата не са достъпни извън класа. Protected означава ще методите или полетата са достъпни само за наследниците на класа
```cs
class Calculator // Името на класа
{
	private: // Достъпен модификатор, който указва дали полетата или методите могат да бъдат достъшни извън класа. Private означава, че полетата и методите не са достъпни извън класа
		int a;
		int b;
	public: // Достъпен модификатор, който указва, че полетата или методите могат да бъдат достъпвани извък класа
		Calculator(int A, int B) // Конструктор
		{
			a=A;
			b=B;
		}
		int sum() // Метода който извършва съмата
		{
			return a + b;
		}
}
```
- Много нишков и едно нишков

> В модерното програмиране това, което изпълява кода са нишките. Много нишков означава, че повече от една нишка може да използва програмата. Пример за многонишкови програми са сърварите. 

- Компилиран и интерпретиран

> Компилиран език се трансформира на машинен по време на компилация, интерпретирания дирекно изпълява кода без трансформиране в машинен език

**г) Среда за разработка (IDE)**
> Интегрираната среда за разработка e софтуерно приложение, което предоставя цялостна среда за разработване на софтуер на програмистите. Или с две думи там е мястото където програмиста дава указания за компютъра. IDE обикновено се състои от редактор на код, инструменти за автоматизиране построяването на изходното приложение и дебъгер, където програмистите могат да одледат кода си за дрешки. Повечето съвременни интегрирани среди предлагат автоматично предсказване и дописване на кода.

**д) Компилиране и интерпретация**
> Компилирането представлява процеса, при който програмният език е трансформира в машинен код, който се чете от процесора. Този процес е автоматизиран от IDE-тата.

> В компютърните науки интерпретаторът е компютърна програма, която директно изпълнява инструкции, написани на език за програмиране или скриптове, без да е необходимо те да са били компилирани в програма на машинен език.

## 2. Променливи и типове от данни
> Какво казахме по-горе променливата е контейнер за данни. По-задълдочено промеливите са имена индикирайки мястото в паметта където сме съхранили стойността.

Начин, по който създаваме променливи (деклариране на променливи)
```cs
int a;
int b;
// Или
int a, b;
```
Програмата горе създава (декларира) две променливи, който ще резервират две места в паметта наименувани `a` и `b`. Използваме думата `int`, за да специфицираме, че променливите ще пазят цели числа. Подобно могат да се създат и променливи, които пазят реални числа, букви, низове, битове, масиви, за които ще говорим по късно и др.

Запазване на стойност в променлива
```cs
int a;
int b;
a = 10;
b = 20;
// Или
int a = 10, b = 20;
```
Достъпване на стойностите на промеливите
```cs
int a;
int b;
a = 10;
b = 20;
print("Value of a ", a);
```
Тоест достъпваме стойностите на променливи когато ги извикаме просто, като напишем тяхното име. Изходът на програмата ще бъде `Value of a 10`

Основни правила:
- Променлива може да пази само един тип данни
- Една променлива трябва първо да се декларира, за да може да се използва
- Имена на променливи не може да се повтарят
- В някой програмни езици не се изисква да се специфицира типът на променливата
- Име на променлива не трябва да е резервирана дума (if, for, void...), не трябва да започва с число

| Тип в програмирането | Тип в реалния свят                               |
| -------------------- | ------------------------------------------------ |
| int                  | Цели числа                                       |
| float                | Реални числа с точност до 4 знака след запетаята |
| double               | Реални числа с точност до 8 знака след запетаята |
| char                 | Символи                                          |
| string               | Низове (масив от символи)                        |
| bool                 | Вярно или грешно                                 |

Особености при променливите от тип реални числа (float)
> Подводния камък при промнеливи от реален тип (float) е, че те не закръглят с точност. Тоест вместо стойността, която се запазва в float променлива да е 3, ще се запази като 3.0001

Глобални променливи
> Глобалните промрнливи са променливи, които са дефинирани извън класове или функции, а са дефинирани в структурата на кода. Те могат да се използват в различни функции или класове
## 3. Пресмятания, аритметични и побитови оператори, изрази
В програмирането всички данни се записвта в рамтта. Тези данни се използват за изпълняването на различни операции.
**а) Аритметични операции**
- Събиране

```cs
int a = 1;
int b = 2;
int sum = a + b;
```
Събираме с оператора +

- Изваждане

```cs
int a = 1;
int b = 2;
int sum = a - b;
```
Изваждаме с оператора -

- Умнпжение

```cs
int a = 1;
int b = 2;
int sum = a * b;
```
Умнпжеване с оператора *

- Деление

```cs
int a = 1;
int b = 2;
int sum = a / b;
```
Делим с оператора /

Особенности при делението:
> Когато делим цели числа получаваме цели числа дори и реалния отговор да е дроб. Тоест ако делим цели числа 5/2 отговора ще бъде 2. Както забелахте чуслото се закръгля до по-ниското. Начин да се избегне това е да запазим резултата в променлива от тип реални числа (float, double).

> Важна особеност при делението, е че, ако делим на 0 се предизвиква грешка, в повечето езици. В други просто се изписва символът за безкрайност.

- Мод

```cs
int a = 3;
int b = 2;
int sum = a % b; // 1
```
Взимаме остатъка от делението (мод) с оператора %

**б) Допълнителни оператори**

- Увеличаване и намаляне

```cs
int a = 5;
a++; // 6
a--; // 5
```

> а++ е съкращение на израза а = а + 1 и а-- е съкращение на израза а = а - 1. Тези изрази използват литерали.

**в) Литерарли**
> В компютърното програмиране литерала е идеята за изразяване на константна стойност в кода на компютърната програма. Литералите за записват в един от general purpose регистрите на процесора. Литералите могат да бъдат чила или реални числа или низове и др. Литералите могат да бъдат предадени на променливи или идентификатор, когато декларирате променлива, можете да инициализирате променливата с литерал. Тоест стойността от тези general purpose регистри може да се записват в рамтта.

**г) Побитови операции**
Побитовите операции не се извършват на математичско ниво, а на бинарно ниво.
Има 4 основни типа побитови операции

- NOT

| A   | NOT |
| --- | --- |
| 0   | 1   |
| 1   | 0   |
- AND


| A   | B   | AND |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 0   |
| 1   | 0   | 0   |
| 1   | 1   | 1   | 
- OR


| A   | B   | OR  |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 1   | 
- XOR


| A   | B   | XOR |
| --- | --- | --- |
| 0   | 0   | 0   |
| 0   | 1   | 1   |
| 1   | 0   | 1   |
| 1   | 1   | 0   | 

> Начина, по който побитовите операции ца изпълняват на цели числа е следния: първо числата трябва да се конвертират в бинарни и операцията се инпълнява на всяко битче от числата.

**д) Бинарни операции**

Както и в десетичните така и в двоичноте числа имаме аритметично операции
- Addition

| Operation | Carry | Result |
| --------- | ----- | ------ |
| 0 + 0     | 0     | 0      |
| 0 + 1     | 0     | 1      |
| 1 + 0     | 0     | 1      |
| 1 + 1     | 1     | 0      |
| 1 + 1 + 1 | 1     | 1      |
- Subtraction

| Operation | Borrow | Result |
| --------- | ------ | ------ |
| 1 - 0     | 0      | 1      |
| 1 - 1     | 0      | 0      |
| 0 - 0     | 0      | 0      |
| 0 - 1     | 1      | 0      |
- Multiplication

| Operation | Result |
| --------- | ------ |
| 1 x 1     | 1      |
| 1 x 0     | 0      |
| 0 x 1     | 0      |
| 0 x 0     | 0      |

- Devision

| Opearion | Result |
| -------- | ------ |
| 0 / 1    | 0      |
| 1 / 1    | 1      | 

- Shifting
![[Pasted image 20220928180512.png]]
![[Pasted image 20220928180515.png]]

## 4. Описание на условни конструкции
Условните конструкции, както споменахме по-рано, са начин код да взима различни решения спрямо определенни условия

Повечето програмни езици имат следните условни конструкции:

-   `if` - Специфицира блок от код, който ще бъде изпълнен, ако условието е вярно
-   `else` - Специфицира блок от код, който ще бъде изпълнен, ако условието е грешно
-   `else if` - Да специфицира ново условие, ако първото е грешно
-   `switch` - Специфицира много блокове от код, които може да изпълним

```cs
if(Условие)
{
	Код
}
else if(Второ условие)
{
	Код
}
else
{
	Код
}
```
```cs
int x = 5;
switch(x)
{
	case 1:
		Код
	break;
	
	case 2:
		Код
	break;
	
	case 3:
		Код
	break;
	
	case 4:
		Код
	break;
	
	case 5: // Този случай ще бъде изпълнен
		Код
	break;
}
```
> За разлика от if , switch не изисква булев израаз, а променлива, чиято стойност зависи кой случай ще се избере

Още един вид условен уператор е туринг оператора `?`. Начина по който се използва е следния:
1. Специфицираме болевото условие
2. Поставяме туринг оператора след условието
3. Специфицираме 2 действия, които ще се извършат зависимост от изхода на нулевото условие и ги разделяме с `:`
```cs
5<3? print(5 is smaller than 3) : print(3 is smaller than 5)
```
> Важно е да  се отбележи че първо специфицираме действието, ако стойността на булевия израс е true,  а после, след ":", специфицираме действирто за false outcome. Този оператор не се  третира от процесора за условен, а за аритметичен

> Друго свойство на условните оператори е, че те могат да са вложение един в друг. Тоест ако искам да провяра дали е ден и дали е време за закуска, мога в тялото на if-а за проверка дали е ден да сложа още един if, който да проверява дали е време за закуска. Това може да се избегне ако се използват логическите изгрази, за които ще говорим по-късно.

```cs
if(is morning)
{
	if(is time for breakfast)
	{
		...
	}
}
```
## 5. Логически изрази и оператори за сравнение

Повечето програмни езици поддържат следните условни операции

-   По-малко: a < b
-   По-малко или равно: a <= b
-   По-голямо: a > b
-   По-голямо или равно: a >= b
-   Равно: a == b
-   Различно: a != b

> Тези логичеки оператори връщат два типа стойности. Вярно и грешно. После `if` операторите използват тези стойности да определят кой блок от код да изпълнят. Тези логически изрази могат да бъдат комбинирани с резервиранете думи `and - &&` и `or - ||`. Тези оператори отново за бинарни защото работят с 2 условия.

| Логически изход 1 | Логически изход 2 | Операнд | Изход |
| ----------------- | ----------------- | ------- | ----- |
| 0                 | 0                 | or      | 0     |
| 0                 | 0                 | and     | 0     |
| 0                 | 1                 | or      | 1     |
| 0                 | 1                 | and     | 0     |
| 1                 | 0                 | or      | 1     |
| 1                 | 0                 | and     | 0     |
| 1                 | 1                 | or      | 1     |
| 1                 | 1                 | and     | 1      |
Пример:

10 < 2 или 2 > 3 - Изход грешно
5 > 2 и 1 == 1 - Изход вярно

> Както споменахме по-горе с примера за сутринта и закуската, вместо да използваме вложен if оператор. Може да използваме следния израс: is morning &&  is time for breakfast


## 6. Циклични оператори
> В програмирането циклите ни дават възможност да изпълним даден блок от код няколко пъти без да го пишем отново и отново. В програмирането един цикъл изисква начална стойностм, условие при което цикала ще спре, тяло на цикала.

> Както забелязваме в основата на while цикълът е условнота конструкция. Преди да има цикли в програмирането са се използвали неща наречели labels, които се използват, като маркери. Тоест слагаме label на даден ред код и след това, когато искаме да се върнем на този ред код изпозлваме go to което ни връща в при label-a който сме специфицирали

Типове цикли:

**a) While цикъл**

Сонтакса на `while` цикъла е следния:

```cs
while (testExpression) {
  // код
}
```
Как работи цикалът

---
- `while` цикъла се проверява `testExpression` в скобите `()`.
- Ако `testExpression` е вярно, кода в цикъла `while` се изпълнява. Тогава, `testExpression` се проверява отново.
- Цикълът се върти докато `testExpression` е грешно **false**.
- Ако `testExpression` е грешно, цикълът се терминира.
---

Следствена диаграма на цикъл while

![flowchart of while loop in C programming](https://cdn.programiz.com/sites/tutorial2program/files/c-while-loop_0.jpg "while loop flowchart")

**б) Do...while цикъл**

`do..while` цикълът е подобен на `while` цикълът с една важна разлика. Тялото на `do...while` цикълът се изпълнява поне веднъж, а после се проверява услловуето

Синтаксиса е следния:

```cs
do {
  // код
}
while (testExpression);
```

---

Как работят do...while циклите
- Тялото на цикъла се изпълнява и после се проверява условието.
- Ако условието е вярно то тялото се изпълнява и след това пак се проверява условието
- Ако условието е грешно цикълът се терминира

---

Следствена диаграма на цикъл do...while

![do while loop flowchart in C programming](https://cdn.programiz.com/sites/tutorial2program/files/c-do-while-loop_0.jpg "do while loop flowchart")

**в) For цикъл**
Синтаксиса е следния:

```cs
for (initializationStatement; testExpression; updateStatement)
{
    // statements inside the body of loop
}
```

---

Как работи for цикълът

- Инициализиращият израз се изпълнява само веднъж
- После се проверява условието, ако то е грешно цикълът се треминира
- Ако обаче, ако условието е вярно се изпълнява `updateStatement` и след това тялото на цикълът
- Това се повтаря докато условието на цикъла е грешно
- 
---
Следствена диаграма на for цикъл

![Flowchart of for loop in C programming](https://cdn.programiz.com/sites/tutorial2program/files/c-for-loop.jpg "for loop Flowchart")

**д) Break и continue**
> Използваме break, ако искаме да терминираме цикълът веднага без значение дали условието е грешно или не. Continue използваме, ако искаме да преминим към следващата итерация на цикъла, ако това е била последната, то тогава цикъла се терминира.

## 7. Същност на подпрограми

> Подпограми или функциите са блокове от код, които могат да бъдат използвани много пъти с  различни прараметри. Една функция име 4 основни конструкции: Връщана стойност, име, аргументи, тяло.

**а) Връщана стойност на функция**
> Има 2 вида функции според това дали връшат или не връщат стойност. Функциите, които връшат стойности трябва да специфицират от какъв тип са тези стойности. Енда функция може да върне само една стойност независимо дали е от тип value или reference. Ако не искаме една функция да не връща стойност трябва да специфицираме с ключо вата дума `void`. Иначе трябва да специфицираме връщана стойност на функцията. Това е като обещание, че след изпълнението на една функция ще получим дадена стойност от един тип

```cs
void print(string message)
{
	print("The message is: " + message);
}
```
Както виждате функцията `print` не връща стойност, а само отпечатва

**б) Име на функция**
> Името на функцията е начина, по който индексираме една функция и ако искаме да я изпълним трябва да използвате точно това име. Възможно е една функция да има едно и съща име, само ако параметрите или връщаната стойност са различни. Това се нарича overloading

**в) Параметри на функция**
> Една функция може да има 0 или много параметри. Параметрите може да са от всеки възможен тип. Параметрите не може да са с едно и също име. 

**г) Тяло на функцията**
> В тялото на една функция описваме кода, който ще се изтълни при извикването на функцията. Важно е да се отбележи, че ако една променлива е дефиниране в тялото на една функция, тя няма да може да бъде използвана извън тялото на функцията.

## 8. Определяне на реда на изпълнение на фрагментите в кода

> Основният поток на изпълнение на програмата е контролен поток. В потока на управление се изпълнява всеки оператор за програмиране, всяка инструкция за програмиране и всяко извикване на функция на програма. Контролният поток на изпълнението на програмата зависи от видовете език за програмиране. Съществуват два вида езици за програмиране: първо, императивен език за програмиране, второ, декларативен език за програмиране.

> В императивния език за програмиране потокът от контрол при изпълнение на програмирането зависи от решението да се следва определен път. Следователно последователността от програмни инструкции се комбинира за изграждане на програмни блокове. Тези блокове с програмни инструкции се използват за дефиниране на лексикални обхвати.

> Потокът на управление на изпълнението на програмата се променя при извикване на функцията. В този случай потокът от управление трябва да напусне своята последователност на изпълнение и да премине към извиканата функция. Следователно контролният поток на изпълнението на програмата зависи от условни или безусловни инструкции за разклоняване.

Потокът на изпълнение на програмата се поддържа и осъществява от програмния брояч. Различните езици прилагат контролния поток от изрази по различен начин. Те са категоризирани по следния начин:

- Използване на безусловно разклоняване, при което управлението прескача към други инструкции за програмиране.
- Използване на условно разклоняване, при което изпълнението на определен набор от инструкции зависи от резултата от оценката на конкретно условие.
- Използването на итерация е многократно изпълнение на определен набор от инструкции. Това изпълнение продължава, докато не бъде изпълнено определено условие.
- Изпълнение на инструкциите за програмиране на функцията и след изпълнение на инструкциите за програмиране управлението се връща на мястото, откъдето е прехвърлено управлението.
- Използване на безусловно спиране, при което изпълнението на програмата спира и не се извършва по-нататъшно изпълнение на програмата.
---
- Етикети (labels)

> Етикетите се използват за промяна на потока на управление. Етикетите обикновено се свързват с безусловни скокове. Етикетите се поставят в инструкциите за програмиране. Когато се изпълни инструкция за програмиране на безусловен скок, управлението търси етикети в блока с инструкции за програмиране, в който е поставена инструкция за програмиране на безусловен скок. По този начин етикетът работи като ориентир в блока с програмни инструкции.

- GoTo

> GOTO е оператор за безусловно прескачане, който се използва за промяна на контролния поток на инструкциите за програмиране. Goto често се използва като ключова дума в езиците за програмиране. Goto принуждава контролния поток на програмата да премине към мястото, където е поставен етикетът.

- Подпрограми

> В много езици за програмиране подпрограмите са известни също като функции. Това е така, защото функциите се използват за намаляване на размера на програмата. Броят пъти, в които функциите се изпълняват, зависи от броя пъти, в които са извикани.

- Последователност

> Това е последователността от инструкции, използвани за проследяване на изпълнението по подреден начин. Писането на инструкции за програмиране в последователност е градивен елемент на програма заедно с итерация или рекурсия.

> Инструкциите за програмиране са написани за изпълнение на определена задача. За да се изпълни определена задача, трябва да има логичен и подреден поток и изпълнение на набор от програмни инструкции. Трябва да има механизъм за определяне на набора от програмни инструкции, които да бъдат изпълнени, за да се изпълни определена задача. Този механизъм също влияе върху контролния поток на програмните инструкции. 

- Условни изрази

> Условни изрази като if-then-else променят контролния поток на изпълнение в зависимост от оценката на условния израз, използван в оператора if-then-else. Друг оператор на контролния поток, който се използва в инструкциите за програмиране, е операторите Case и Switch. При switch управлението на израза преминава към онази част от програмата, за която стойността на оператора switch е равна на тази на константата. Ако стойността на оператора switch не съответства на нито една от посочените константи, тогава се изпълнява частта по подразбиране на оператора switch. 

- Цикли

> След това програмната конструкция, използвана за промяна на контролния поток на програмната инструкция, е цикълът. Циклите се използват за многократно изпълнение на определен набор от програмни инструкции. Инструкциите за програмиране в рамките на цикъла се изпълняват многократно, докато условието на цикъла стане невярно. Циклите също могат да се изпълняват определен брой пъти. Броят пъти, в които циклите се изпълняват върху целочислената стойност, дефинирана в цикъла.

> Съществуват случаи, при които изпълнението на цикъл е необходимо безкраен брой пъти. Безкрайните цикли се изпълняват безкрайно, докато възникне грешка или настъпи срив на системата. 

- Рекурсия

> Рекурсията също е оператор на контролен поток, функция, използваща рекурсия, която се извиква сама. По този начин рекурсията е алтернатива на итерацията. Освен това функцията, която използва рекурсия, има кратки кодове в сравнение с функциите, които използват итеративни изрази. По този начин времето за изпълнение на рекурсивната функция е по-малко в сравнение с итеративните функции.